# Jasmine Express Mock

Learn about unit testing and mocks with Jasmine and **SpyOn**.

## Step One

Create our project using our script.

```bash
CreateExpressProject Week04-JasmineExpressMock
```

I maintain my copy of this script here:

**JsObjects/Utilities/NodeInstall/CreateExpressProject**

To get the most recent copy, navigate to the JsObjects folder and call **git pull**. You can then copy my version of the file into your bin directory. Alternatively, compare my version with yours:

```bash
meld $JSOBJECTS/Utilities/NodeInstall/CreateExpressProject ~/bin/CreateExpressProject
```

## Step Two: Set up Unit Testing {#unit-test-setup}

There are a number of steps you need to go through to properly configure you project for unit testing. In particular, we need to set up a:

1. test runner called **Karma**
1. build utility called **Grunt**
1. syntax checker called **JsHint**
1. testing framework called **Jasmine**
1. And it creates a default unit test in a directory called **spec**

**NOTE**: *Before going further, make sure you have installed **js-beautify**. This utility can help you properly format and indent your javascript files.*

```
npm install -g js-beautify
```

To complete the steps outlined above can use this script to set up Karama, Grunt and Jasmine:

```
#! /bin/bash

UNIT_TEST=$ELF_TEMPLATES/UnitTest

cp $ELF_TEMPLATES/Gruntfile.js .
cp $ELF_TEMPLATES/karma.conf.js .
sed -i '/\s\s}$/r '$ELF_TEMPLATES'/DevDependencies.json' package.json
js-beautify -r package.json 
sed -i "s/{$/{ 'use strict';/" routes/index.js
sed -i "s/{$/{ 'use strict';/" routes/users.js
sed -i "s/{$/{ 'use strict';/" app.js

npm install
mkdir spec
cp $UNIT_TEST/test-basic.js spec/.
```

This script is called [TestReady][tr] and it is maintained in:

```
JsObjects/Utilities/Templates/NodeInstall
```

The script first copies two files from ELF_TEMPLATES\UnitTest:

* Gruntfile.js: Configure Grunt.
* karama.conf.js: Configure Karma

It then adds a set of Grunt and Karma related packages to **package.json**. After the code is added, **package.json** is not very well formated and indented. To clean that up, we use **js-beautify**.

The next step is to double check that we have added **use strict** statments to several files that are auto-generated by express.

We then run **npm install**, and, as a final step, copy in a very simple unit test.

To confirm that everything is working, run **grunt test**. If you see output like the following, then all has gone well:

```
  Elvenware Simple Plain Suite
    ✓ expects true to be true

PhantomJS 1.9.8 (Linux 0.0.0): Executed 1 of 1 SUCCESS (0.041 secs / 0.001 secs)
TOTAL: 1 SUCCESS
```

If you get errors related to **JsHint**, then open **result.xml** in a browser with either of these commands:

```
chromium-browser result.xml
firefox result.xml
```

Once the file is loaded in your browser, you can check for updates to **result.xml** by pressing F5 to refresh the browser. This means you don't have to re-run one of the above commands each time you attempt to fix a syntax error and run **grunt test** to test your work. Instead, just refresh your browser.

[tr]:https://github.com/charliecalvert/JsObjects/blob/master/Utilities/NodeInstall/TestReady


## Step Three: Test our Test Framework {#test-test}

The **DevReady** script creates a single simple test that it puts in the **spec** folder:

```javascript
/**
 * Created by charlie on 10/7/15.
 */

describe("Elvenware Simple Plain Suite", function() {

    'use strict';

    it("expects true to be true", function() {
        expect(true).toBe(true);
    });

});

```

This test has a single purpose:

* It tests whether **true** is actually **true**

Why would one want to run such a test? Simply to find out if **karma** and the **jasmine** unit test library are set up correctly. Since we know that **true** is equal to true, any errors we see are almost certainly the result of problems in our configuration, not in our test. If our test succeeds, then we know we have set things up correctly. In particular, we want to see a line that looks like this:

```
  Elvenware Simple Plain Suite
    ✓ expects true to be true
```

## Step Four: Create Useful Tests {#useful-test}

Assuming we can get our single test to pass, the next step will be copy in some tests that do a bit more:

```javascript
describe("Elvenware Object Number Suite", function () {

    'use strict';

    it("Call a function in getNumber that returns 9", function () {
        expect(getNine()).toBe(9);
    });

    it("Test that we can parse the value expected to be returned from getJSON call", function() {
        var response = {nine: 10};
        queryServer.parseSimpleJson(response);
        expect(queryServer.queryResult).toBe(10);
    });

    it("tests ajax call", function() {
        spyOn($, 'ajax').and.callFake(function (ajaxConfig) {
            ajaxConfig.success({"nine": 9});
        });
        queryServer.getAjaxServerNine();
        expect(queryServer.queryResult).toBe(9);
    });

    it("tests getJSON call", function() {
        spyOn($, 'getJSON').and.callFake(function (url, success) {
            success({"nine": 9});
        });
        queryServer.getJsonServerNine();
        expect(queryServer.queryResult).toBe(9);
    });

    it("tests getJSON call with fail 9", function () {
        spyOn($, 'getJSON').and.callFake(function (url, success) {
            success({
                "nine": 9
            });
            return {
                fail: function() {}
            };
        });
        queryServer.getJsonServerNineWithFail();
        expect(queryServer.queryResult).toBe(9);
    });
});

```

The first method checks to see if there is a method called **getNine** that returns the number nine.

The second test checks to see if there is an object call bar, with a method called **parseSimpleJson.**. If that method is passed a JavaScript object with a property called **nine** set to the value **10** then it should return the value 10. Remember, we haven't written a method that does that yet, we have just stated that we want to create such a method.

The third test checks that a method of **queryServer** called **getAjaxServerNine** sets a property of **queryServer** called **queryResult** to the number nine. **getAjaxServerNine** is problematic for us because it uses the jQuery **ajax** method to call the server and retrieve some JSON. We don't want our test to rely on the server working properly, or even to rely on the fact that it is running at all. So we use the Jasmine **spyOn** method to mock the call. We don't really call the server, instead the **spyOn** method uses **callFake** to simulate the call to the server. In particular, it passes to the **getAjaxServerNine** nine **success** method a mock up of the data it would recieve had the call to the server succeeded.

Take a moment to consider how the **ajax** method it works. It calls the server, and the server sends back some data. In this case, we know that the server shoud send back a JSON object shaped like this:

```JSON
{ 
	"nine": 9
}
```

We therefore set up a **callFake** to the success function, passing in expect value. Our tests then confirms that the success method knows how to successfully handle the data it might receive from the server.

At first, this technique of mocking objects seems like it can't possibly be useful. But it is useful. Very useful. In fact, it simulates exactly what happens when a successful call to the server is made, only we don't actually have to call the server. Instead we can **mock** such a call. The Jasmine **spyOn** method is a very clever, and useful, piece of code.

The fourth and fifth tests are much like the previous test, only we call **$.getJSON** instead of **$.ajax**. Note that we have to fake the call differently depending on how we implement our call to **$.getJSON**. In particular, if we call **.fail** to handle errors, then we need to take that into account when we write our test. We don't have to jump through this hoop if we use **sinon** instead of **spyOn**.

**NOTE**: *Which is better: **spyOn** or **sinon**? It is a tough call. There is more setup work to do when using **sinon**, but the calls themselves are simpler. Or more precisely, they are all the same since we don't have to craft a different **callFake** for each type of method we test. With **spyOn** there is no additional setup, and it is educational and perhaps kind of fun, if challenging, to figure out how to craft our **callFake** implementation.*



## Step Five: Write Code

Now that we have defined our tests, the next step is to write our program. If the code we write passes our tests, then can assume it is working properly.

Place the following code in **control.js:**


```javascript

function getNine() {
    'use strict';
    return 9;
}

var queryServer = {

    url: './simple.json',

    queryResult: null,

    parseSimpleJson: function (simpleJson) {
        'use strict';
        queryServer.queryResult = simpleJson.nine;
    },

    getAjaxServerNine: function () {
        'use strict';

        $.ajax({
            url: queryServer.url,
            success: function (simpleJson) {
                queryServer.parseSimpleJson(simpleJson);
                console.log(queryServer.queryResult);
            },
            error: function (jqXHR, textStatus, errorThrown) {
                console.log(textStatus + "incoming Text " + jqXHR.responseText);
            }
        });
    },

    getJsonServerNine: function () {
        'use strict';

        $.getJSON(queryServer.url, function (simpleJson) {
            queryServer.parseSimpleJson(simpleJson);
            console.log(queryServer.queryResult);
            $('#serverResult').html(queryServer.queryResult);
        });
    },

    getJsonServerNineWithFail: function () {
        'use strict';
        console.log(queryServer.url);
        $.getJSON(queryServer.url, function (simpleJson) {
            queryServer.parseSimpleJson(simpleJson);
            console.log(queryServer.queryResult);
            $('#serverResult').html(queryServer.queryResult);
        }).fail(function (error) {
            console.log(error);
        });

    }
};
```

The code shown above contains one standalone method called **getNine** and one JavaScript object called **bar**.

## Grunt

The grunt utility is configured in a file called **Gruntfile.js**. You can do many, many things in this file. In our case, however, we have two relatively simple goals:

* Establish the config file for **karma**
* Configure **jshint**

It should be fairly simple for you to pick out the places where these tasks are performed:

```javascript
module.exports = function(grunt) {
	'use strict';

	grunt.initConfig({

		pkg : '<json:package.json>',

		karma : {
			karma : {
				configFile : 'karma.conf.js'
			}
		},

		jshint : {
			files : [ '**/*.js' ],

			options : {
				ignores : [ 
				     '**/node_modules/**', '**/components/**'
				],
				reporter : 'checkstyle',
				reporterOutput : 'result.xml',
				strict : true,
				globals : {
					describe : true,
					afterEach : true,
					beforeEach : true,
					inject : true,
					it : true,
					jasmine : true,
					expect : true
				}
			}
		},

	});

	grunt.loadNpmTasks('grunt-karma');
	grunt.loadNpmTasks('grunt-contrib-jshint');
	grunt.registerTask('test', [ 'jshint', 'karma' ]);

};

```

The last three lines perform two tasks:

* The first two lines load libraries that define how grunt controls **karma** and **jshint**
* The third line defines a task called **test** that runs both **jshint** and **karma**

If the **jshint** task does not pass, then **karma** will never be run. In other words, if **jshint** finds that your code is not syntactically correct, then **karma** will never get a chance to your tests.

## Karma config

```javascript
/* global process: true */

module.exports = function(config) {
    'use strict';
    
    config.set({
        // base path, that will be used to resolve files and exclude
        basePath: './',

        frameworks: ['jasmine'],
        
        files: [
            'public/components/jquery/dist/jquery.min.js',
            'public/javascripts/*.js',
            'spec/test*.js'
        ],

        // list of files to exclude
        exclude: [
        ],

        reporters: ['spec'],

        // web server port
        port: 9876,

        // enable / disable colors in the output (reporters and logs)
        colors: true,

        // level of logging
        logLevel: config.LOG_INFO,

        // enable / disable watching file and executing tests whenever any file changes
        // CLI --auto-watch --no-auto-watch
        autoWatch: true,

        // Start these browsers, currently available:
        browsers: ['PhantomJS'],

        // If browser does not capture in given timeout [ms], kill it
        captureTimeout: 20000,

        // Set to false to watch files for changes
        singleRun: true,

        plugins: ["karma-jasmine",
            "karma-spec-reporter",
            'karma-phantomjs-launcher']

    });
};
```

## Hint

Normally, it is simplest to use the **headless** phantomjs browser. However, it does not contain the great debugger found in Chrome. To switch to Chrome, change the bottom of **karma.conf.js** to look like this:

```
// Start these browsers, currently available:
// browsers: ['PhantomJS'],
browsers: ['Chrome'],

// If browser does not capture in given timeout [ms], kill it
captureTimeout: 20000,

// Set to false to watch files for changes
singleRun: false,

plugins: ["karma-jasmine",
    "karma-spec-reporter",
    "karma-chrome-launcher",
    "karma-phantomjs-launcher"]
```

Be sure to install the chrome-launcher:

```
npm install karma-chrome-launcher --save
```