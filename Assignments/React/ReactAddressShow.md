# React Address Show

We are building on the work from the **AddressComponent** assignment.

In this assignment, we have several steps we want to complete. Among them are:

- Divide the Address Component up into:
  - A component that owns the data: **Address**
  - A component that displays the data: **AddressShow**
  - Update Tests
- Insure that clicks on the Button work but that **Address** does the real work. **AddressShow** is mostly about the interface and does little real work other than display JSX.
  - Update Tests

## Divide

The first step is to split **Address** and **AddressShow** into two distinct components. In particular, we will create a new component called **AddressShow** and put the **render** method of **Address** in it:

- **AddressShow** contains only the **render** method from the original **Address** component
- **Address** contains the constructor, the **setAddress** method, and a one line **render** method that references **<AddressShow/>** and passes it props. This render method will be explained later in this assignment.

The **Address** component will handle our data, **AddressShow** will display the data and the button.

## Create AddressShow Project

To get started, make a copy of Address Components assignment and call it **address-show**. For instance:

    cp -r week03-react-address/ week05-address-show

Or, if you prefer use Pascal case for the new project:

    cp -r week03-react-address/ Week05-AddressShow

There are many ways to do the same thing, and it doesn't really matter which one you prefer.

## Testing First Steps

The first step will be set up our (initially) failing tests for **AddressShow** in **AddressShow.test.js**:

```javascript
// IT'S UP TO YOU TO INCLUDE THE RIGHT IMPORTS

describe('AddressShow Shallow Suite', function () {

    const debug = false;

    /*
     * Display debug information about a DOM node of a component by index
     * @param {object} wrapper - The HTML generated by your component
     * @param {number} index - Index of HTML element you want to see.
     * @param {boolean} talkToMe - Speak even if quiet is true
     */
    const getIndex = (wrapper, index, talkToMe) => {
        if (debug || talkToMe) {
            const ninep = wrapper.find('div#addressShow').childAt(index).debug();
            console.log('NINEP:', ninep);
        }
    };

    const defaultFieldTest = (name, index, talkToMe) => {
        const wrapper = shallow(<AddressShow address={addresses[0]}  />);
        const welcome = <p className="App-intro">{name}</p>;
        getIndex(wrapper, index, talkToMe);
        expect(wrapper.contains(welcome)).toEqual(true);
    };

    const afterClickFieldTest = (name, index, talkToMe) => {
        const wrapper = shallow(<AddressShow address={addresses[1]}  />);
        const welcome = <p className="App-intro">{name}</p>;
        getIndex(wrapper, index, talkToMe);
        expect(wrapper.contains(welcome)).toEqual(true);
    };

    it('renders and displays the default first name', () => {
        defaultFieldTest('firstName: unknown', 0);
    });

    it('renders and displays the default first name', () => {
        afterClickFieldTest('firstName: Patty', 0);
    });

    // EVENTUALLY YOU WILL NEED TO WRITE MORE TESTS LIKE THE LAST TWO
    // THE GOAL WILL BE TO TEST ALL THE PROPERTIES OF OUR COMPONENT.
    // AT FIRST, HOWEVER, JUST KEEP THESE TWO TESTS. WHEN THEY START
    // PASSING, THEN ADD TESTS FOR THE OTHER PROPERTIES SUCH AS LASTNAME...

});
```

Our goal now will be to get these tests to pass.

## Rename the React Component

The React component you created may be in a file called **App.js** or perhaps you have renamed it to **Addresss.js**. In either case, rename both the file and the class inside it to **AddressShow**.

This is a task the WebStorm can help you complete.

- Right click on the file in the Project pane and choose to copy it.
- Right click on the components directory and choose to paste it.
- Rename the new file to **AddressShow.js**

In **AddressShow**, rename the class from **Address** to **AddressShow**:

```javascript
class Address extends Component { ... }      <=== ORIGINAL
class AddressShow extends Component { ... }  <=== EDITED VERSION
```

Then, down at the bottom of the file, make the same change:

```javascript
export default Address;      <=== ORIGINAL
export default AddressShow;  <=== EDITED VERSION
```

## Properly Refactor Our Components

If you have not done so already, you should now further refactor your components as follows:

| Component     | Task     |
| :------------- | :------------- |
| Header       | Display the Header      |
| GetFile   | The simple **state.file**, **getFile**, **render** component from week one or two. |
| Address   | **constructor**, **setAddress** and simple render method to be explained later.  |
| AddressShow   | Only a relatively lengthy render method to display all the props such as **firstName**, **lastName, etc**.  |
| App  | Only a relatively short render method to instantiate the **Header**, **GetFile**, **Address**, **AddressShow** |
| index.js   | Instantiates **App**   |

Here is the way it looks in WebStorm:

![Webstorm project view][wspv]

Here is our new **index.js**:

```JavaScript
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './components/App';

import registerServiceWorker from './registerServiceWorker';

ReactDOM.render(
    <div>
        <App/>
    </div>,
    document.getElementById('root'));
registerServiceWorker();
```

Here is our new **components/App.js**:

```javascript
import React, {Component} from 'react';
import '../App.css';
import Address from './Address'
import Header from './Header';
import GetFile from './GetFile';


class App extends Component {
    render() {
        return (
            <div className="App">
                <Header/>
                <GetFile/>
                <Address/>
            </div>
        );
    }
}

export default App;
```

We don't see **AddressShow** in **App** because it will be created by the **Address** component.

## Data

We will no longer load **addresses** in **index.js**. Instead, **Address** owns the data. Move the import statement from **index.js** to **Address.js** and straighten out the path:

```javascript
import addresses from '../address-list';
```

**NOTE**: _Recall that our goal is to perform a complete mind-meld with the file system of our OS. Some part of your brain must become the file system, and you should take great joy and comfort from this fact. In particular, it should be intuitively obvious that the relative path part of the import statement must change after we move this line of code from a file in the **src** directory to a file in the **src/components** directory. You should also grok immediately the difference between a relative path that contains one dot and one that contains two dots. You shouldn't have to think about it any more than you have to think how to tie your shoes. The knowledge should just be there, fully formed, in your brain without thought or effort. I should perhaps remind you that this isn't a Linux thing, as you would have the same issue on Windows._

Lets also stop working with the individual fields in **Address**. Instead, we will work with a single record from the **addresses** array.

```javascript
import addresses from '../address-list';

class Address extends Component {
    constructor(props) {
        super(props);

        this.addressIndex=0;        
        this.state = {
            address: addresses[this.addressIndex]  <=== HERE
        };
        this.debug = true;
    }
}
```

We create an **addressIndex** property and use it to index into our array of addresses. Our state tracks only a single address since that is all that **AddressShow** needs to know.

**NOTE**: _I'm having some doubts here as to whether this is the best way to do this. Certainly it works, but there may be a more elegant solution. I'll think about it._

We now radically strip down the **render** method for **Address**. Rather than render the address fields here, we will pass **this.state.address** to **AddressShow** and let that component render it:

```javascript
render() {
    if (this.debug) { console.log("ADDRESS RENDER"); }
    return (
        <div className="App">
            <AddressShow address={this.state.address} />
        </div>
    );
}
```

## AddressShow Receives the Address Data {#props-address-data}

The only thing that **AddressShow** really needs to do is display our **Address** record. It turns that at this time, **AddressShow** does not need a constructor, since there is no set up work need to get the object going. However, if it did need one, it might look like this:

```javascript
constructor(props) {
    super(props);
    this.debug = true;
    if (this.debug) {
      console.log('SHOW ADDRESS CONSTRUCTOR', this.props.address);
    }
}
```

As you can see, the constructor is passed **props**. As you know, **props** is the state passed to the object by its parent, which in this case is **Address**. This means that **this.props.address** in **AddressShow** is "the same thing" as **this.state.address** in the **Address** component. The data is passed from the **Address** render method to the **AddressShow** constructor.

You can keep the above constructor, but you should strip everything else from **AddressShow** except the **render** method. In the **render** method's JSX, reference the fields of the **address** object with **props** rather than **state**.

**NOTE**: _Since the constructor for **AddressShow** doesn't do anything, the only thing we really need in **AddressShow** is the render method, but we are keeping the constructor for pedagogical purposes. Or not, it is up to you. It might be simpler just to open the Developer tools at runtime and put a breakpoint on the **AddressShow** render method to confirm that your props are being passed as expected._

## Logging {#quiet-log}

Since we don't really need the **constructor**, and yet we have implemented it anyway to help illustrate a point, we might as well see if we can find a way to complicate the code further.

As you probably know, **console.log** is both curse and blessing. Let's try to emphasize the blessing and mitigate the curse by creating a single place where we call the offending method:

```javascript
constructor(props) {
    super(props);
    this.debug = true;
    this.log('ADDRESS SHOW CONSTRUCTOR', this.props.address);
}

log(message, message2 = '', message3 = '') {
    if (this.debug) {
        console.log(message, message2, message3);
    }
}
```

Now we can toggle a single variable, **this.debug**, whenever we want to turn down the volume. For instance, we might want to log to the console in our render method. In the new system we would do it like this:

```javascript
render() {
    this.log("SHOW ADDRESS RENDER", this.props);
    return ( ... );
}
```

Now we can change the **this.debug** property from **true** to **false** to toggle the use of **console.log** throughout the object. There are other solutions, and better loggers, but this is a bit of a start on understanding the subject.

**NOTE**: _I state the name of the object in logging message to help me track down where it is coming from. Fancy loggers can give us more information in simpler ways, but we could do this:_

```javascript
constructor(props) {
    super(props);
    this.debug = false;
    this.log('CONSTRUCTOR', this.props.address);
}

log(message, message2 = '', message3 = '') {

    if (this.debug) {
        const label = this.constructor.name + ': ';   < === HERE
        console.log(label, message, message2, message3);
    }
}

render() {
    this.log("RENDER", this.props);
}
```

_We are using **this.constructor.name** to get the name of our component._

## Rendering the Data

It should come as no surprise that **AddressShow** can, at least for now, render an address with almost the same code that we used in **Address**. The change will be simply to work with **props** rather than **state**:

```javascript
render() {
    this.log("SHOW ADDRESS RENDER");

    return (
        <div className="App">
            <p className="App-intro">
                firstName: {this.props.address.firstName}
            </p>

            // CODE OMITTED HERE

        </div>
    );
}
```

Note that we don't write **this.props.firstName** but **this.props.address.firstName**. This is because we pass in the whole address object, rather than a set of individual properties representing each field. One could argue the merits of each technique, but I like this one because it is relatively simple.

## Understanding Testing Child Components

Our next step will be to get the button click working. First, we should create tests that fail until we get our code working.

These tests will look a lot like the tests you did for the original **Address** component that contained both paragraphs and buttons. That was the way things looked before you moved the paragraphs and buttons into Tag it, then **AddressShow**.

There is one important change that you need to make. This has to do with Enzyme and the **shallow** vs **mount** methods.

Suppose one component nests another. For instance, suppose that your custom component **MyComponent** renders a second component called **MyOtherComponent**. Here is **MyComponent&#39;s** render method :

```javascript
class MyComponent extends Component {
  render() {
      return (
          <div>
              <MyOtherComponent />
          </div>
      );
  }
}
```

Here **MyComponent** does nothing but ask **MyOtherComponent** to render itself.

In cases like this, if you use Enzyme&#39;s [shallow][enzsh], your tests will only see the output from **MyComponent**. Indeed, that is often what you want. But sometimes, it is best to have the tests know about the output from both **MyComponent** and **MyOtherComponent**. To do that, you use **mount** rather than **shallow**. We usually do this:

```javascript
import { shallow } from 'enzyme';
```

If you want to see output from both components, then do this:

```javascript
import { mount } from 'enzyme';
```

[enzsh]:https://github.com/airbnb/enzyme/blob/master/docs/api/shallow.md

## Writing Tests for Child Components {#writing-child-tests}

The first step will be to load **mount** rather than **shallow** from enzyme.

```javascript
import React from 'react';
import Address from '../components/Address';
import { mount } from 'enzyme';
import addresses from '../address-list';
import ElfDebugEnzyme from '../ElfDebugEnzyme';
const elfDebugEnzyme = new ElfDebugEnzyme(false, 'NaiveAddressEdit.test.js');
import '../css/index.css';

const address = addresses[0];

describe('Naive Address Edit Mount Jest Suite', function () {

    it('renders and displays the default last name', () => {
        const wrapper = mount(<Address address={address}  />);
        const welcome = <p className='App-intro'>lastName: unknown</p>;
        elfDebugEnzyme.getIndex(wrapper, 'div#addressShowRender', 1, true);
        expect(wrapper.contains(welcome)).toEqual(true);
    });

    it('renders button click message for first name', () => {
        const wrapper = mount(<Address address={address}/>);
        const patty = <p className='App-intro'>lastName: Murray</p>;
        wrapper.find('button#showAddressClick').simulate('click');
        elfDebugEnzyme.getIndex(wrapper, 'div#addressShowRender', 1, true);
        expect(wrapper.contains(patty)).toEqual(true);
    });

});
```

After that, the tests look more or less the same.

## Writing Generic, Resuable Tests {#generic-tests}

Some tests are so similar that you can create a test blueprint, and call it:

```javascript
import React from 'react';
import Address from '../components/Address';
import { mount } from 'enzyme';

import addresses from '../address-list';
import '../css/index.css';

const address = addresses[0];

describe('Address mount Suite', function () {

    var quiet = true;

    /*
     * @param {object} wrapper - Container for a bunch of HTML nodes
     * @param {number} index - Index of HTML element.
     * @param {boolean} talkToMe - Speak even if quiet is true
     */
    const getIndex = function(wrapper, index, talkToMe) {
        if (!quiet || talkToMe) {
            const ninep = wrapper.find('div#addressShowRender').childAt(index).debug();
            console.log('NINEP:', ninep);
        }
    };

    const defaultFieldTest = (name, index, talkToMe) => {
        const wrapper = mount(<Address address={address}  />);
        const welcome = <p className="App-intro">{name}</p>;
        getIndex(wrapper, index, talkToMe);
        expect(wrapper.contains(welcome)).toEqual(true);
    };

    const afterClickFieldTest = (name, index, talkToMe) => {
        const wrapper = mount(<Address address={address}/>);
        const patty = <p className="App-intro">{name}</p>;
        wrapper.find('button#setAddress').simulate('click');
        getIndex(wrapper, index, talkToMe);
        expect(wrapper.contains(patty)).toEqual(true);
    };

    it('renders and displays the default first name', () => {
       defaultFieldTest('firstName: unknown', 0);
    });

    it('renders and displays the default last name', () => {
       defaultFieldTest('lastName: unknown', 1);
    });
});

```

Note that once you created the generic **defaultFieldTest** and **afterClickFieldTest** methods you can call them very simply with code that is not likely to break:

```javascript
it('renders and displays the default street', () => {
    defaultFieldTest('street: unknown', 2);
});
```

## Understanding getIndex

I've moved these methods into ElfDebugEnzyme.

- [http://bit.ly/elf-debug-enzyme](http://bit.ly/elf-debug-enzyme)

Note the **getIndex** method that replaces our **getFirst** method. This will help you pick out individual components from the render method of **AddressShow**.

```javascript
/*
 * @param {object} wrapper - Container for a bunch of HTML nodes
 * @param {number} index - Index of HTML element.
 * @param {boolean} talkToMe - Speak even if quiet is true
 */
const getIndex = function(wrapper, index, talkToMe) {
    if (!quiet || talkToMe) {
        const ninep = wrapper.find('div#addressShowRender').childAt(index).debug();
        console.log('NINEP:', ninep);
    }
};
```

In this case, I've made an exception to my general rule, and added some comments. This means something is probably wrong. I shouldn't need them, but I think we do here.

You already know what **wrapper** is: it's the collection of HTML elements that Enzyme culled from the DOM. In particular, it is a DIV, a bunch of P elements, and a BUTTON. **talkToMe** is added as a way of asking the method to ignore the **quiet** variable. Even if **quiet** is set to **true**, the component will still render output if **talkToMe** is set to **true**. It's a way of saying: "Ignore all the other calls to **getIndex** except those that have **taslkTome** set to **true**."

## AddressShow Modify View with Button Click {#modify-view}

The next step will be to set up a button click for **AddressShow**. Recall that we deleted all the code except the render method a nominal constructor from **AddressShow**. Thus our button click no longer works, even if the button itself is still there.

We said earlier that **AddressShow** would display our data, and that **Address** would manipulate, modify and save our data. So our code for handling the button click belongs in Address. It is essentially the same code we had before, but now it is somewhat simpler since we are working on with the piece of data in our state:

```javascript
onAddressChange = (event) => {
    this.addressIndex = 1;   

    this.setState({
        address: addressList[this.addressIndex]
    })
};
```

So now we have the method for changing our state. But that method is in **Address** and in our button is in **AddressShow**. How do we connect them?

The solution is to pass the **onAddressChange** function object to **AddressShow** in the render method of **Address**:

```javascript
<AddressShow
    address={this.state.address}
    setAddress={this.setAddress}
/>
```

As you can see, we are now passing not one, but two **props** to **AddressShow**.

And here is all we need to do in **AddressShow**. At the bottom of the render method, modify the button to look like this:

```javascript
<button id="showAddressClick" onClick={this.props.setAddress}>Show Address</button>
```

Note that I am both setting the **onclick** method to the function object passed from the **Address** object, and also being sure to create a unique **id** which is a portmanteau derived from the object's name and the button's purpose.

## Turn it in

Add, commit then push. Then Tag. Push you tag. When you turn in the assignment, give me the tag and the directory in which you did your work. I may just look at your most recent code, but being able to go back to where you were when you submitted the assignment can be helpful.

## Hint Tagging

- [Git Tag][git-tag]
- [Understanding Tags][under-tag]

## Hint Breakpoint {#breakpoint}

The debugger and breakpoints are essential tools. I personally can do little without them.

- Start your program.
- Go to Chrome or Chormium
- F12 to start the developer tools.
- Click the Sources page
- Click **webpack** in the "project view" on the left
- Select a file
- Click in the gutter to set a breakpoint.
  - In this case I choose App.js and put the breakpoint in the constructor on line 7
  - You could pick any file and put the break point anywhere there is an active line.
  - Press F5 to rerun to your breakpoint.

![Breakpoints][breakpoint]

[breakpoint]: https://s3.amazonaws.com/bucket01.elvenware.com/images/breakpoint01.png

[git-tag]: http://www.elvenware.com/charlie/development/cloud/Git.html#git-tag

[under-tag]: http://www.elvenware.com/charlie/development/cloud/Git.html#understanding-tags

[wspv]: https://s3.amazonaws.com/bucket01.elvenware.com/images/address-show-project.png
